/*
 * BrawlCardGameView.java
 */
package brawlcardgame;

import brawlcardgame.SettingsManager.Setting;
import brawlcardgame.logic.BrawlGameEngine;
import brawlcardgame.state.BrawlGameState;
import brawlcardgame.state.Direction;
import brawlcardgame.logic.PlayerAction;
import brawlcardgame.state.PlayerID;
import java.awt.Color;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;
import org.jdesktop.application.Action;
import org.jdesktop.application.SingleFrameApplication;
import org.jdesktop.application.FrameView;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.border.LineBorder;
import javax.swing.text.html.HTMLDocument;
import javax.swing.text.html.HTMLEditorKit;
import org.netbeans.lib.awtextra.AbsoluteConstraints;
import org.netbeans.lib.awtextra.AbsoluteLayout;

/**
 * The application's main frame.
 */
public class BrawlCardGameView extends FrameView implements Observer
{

   private BrawlGameEngine controller;
   private BrawlGameState state;
   private ArrayList<JPanel> lanes;
   private static final int kVertCenter = 200;
   private static final int kCardOffset = 25;
   private static final int kHorizCenter = 55;

   public void setState(BrawlGameState state)
   {
      this.state = state;
   }

   public BrawlCardGameView(SingleFrameApplication app)
   {
      super(app);

      initComponents();
      initViewHierarchy();
   }

   public void setController(BrawlGameEngine controller)
   {
      this.controller = controller;
   }

   @Action
   public void showInstructionsBox()
   {
      if (instructionsBox == null)
      {
         JFrame mainFrame = BrawlCardGameApp.getApplication().getMainFrame();
         instructionsBox = new BrawlCardGameInstructionsBox(mainFrame);
         instructionsBox.setLocationRelativeTo(mainFrame);
      }
      BrawlCardGameApp.getApplication().show(instructionsBox);
   }

   @Action
   public void showCardDescriptionsBox()
   {
      if (descriptionsBox == null)
      {
         JFrame mainFrame = BrawlCardGameApp.getApplication().getMainFrame();
         descriptionsBox = new BrawlCardDescriptionsBox(mainFrame, state);
         descriptionsBox.setLocationRelativeTo(mainFrame);
      }
      BrawlCardGameApp.getApplication().show(descriptionsBox);
   }

   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
   @SuppressWarnings("unchecked")
   // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
   private void initComponents() {

      mainPanel = new javax.swing.JPanel();
      P1Area = new javax.swing.JPanel();
      P1Hand = new javax.swing.JPanel();
      P1HandText = new javax.swing.JLabel();
      P1Discard = new javax.swing.JPanel();
      P1DiscardText = new javax.swing.JLabel();
      P1Deck = new javax.swing.JPanel();
      P1DeckText = new javax.swing.JLabel();
      P1Character = new javax.swing.JLabel();
      playArea = new javax.swing.JPanel();
      lane0 = new javax.swing.JPanel();
      lane2 = new javax.swing.JPanel();
      lane1 = new javax.swing.JPanel();
      P2Area = new javax.swing.JPanel();
      P2Hand = new javax.swing.JPanel();
      P2HandText = new javax.swing.JLabel();
      P2Discard = new javax.swing.JPanel();
      P2DiscardText = new javax.swing.JLabel();
      P2Deck = new javax.swing.JPanel();
      P2DeckText = new javax.swing.JLabel();
      P2Character = new javax.swing.JLabel();
      menuBar = new javax.swing.JMenuBar();
      javax.swing.JMenu fileMenu = new javax.swing.JMenu();
      newGameMenuItem = new javax.swing.JMenuItem();
      javax.swing.JMenuItem exitMenuItem = new javax.swing.JMenuItem();
      javax.swing.JMenu helpMenu = new javax.swing.JMenu();
      javax.swing.JMenuItem aboutMenuItem = new javax.swing.JMenuItem();
      descriptionsMenuItem = new javax.swing.JMenuItem();

      org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(brawlcardgame.BrawlCardGameApp.class).getContext().getResourceMap(BrawlCardGameView.class);
      mainPanel.setFont(resourceMap.getFont("mainPanel.font")); // NOI18N
      mainPanel.setMinimumSize(new java.awt.Dimension(450, 0));
      mainPanel.setName("mainPanel"); // NOI18N
      mainPanel.setFocusable(true);
      mainPanel.setPreferredSize(new java.awt.Dimension(450, 700));
      mainPanel.setRequestFocusEnabled(false);
      mainPanel.setSize(new java.awt.Dimension(450, 700));
      mainPanel.addKeyListener(new java.awt.event.KeyAdapter() {
         public void keyPressed(java.awt.event.KeyEvent evt) {
            mainPanelKeyPressed(evt);
         }
      });

      P1Area.setBackground(resourceMap.getColor("P1Area.background")); // NOI18N
      P1Area.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
      P1Area.setName("P1Area"); // NOI18N
      P1Area.setPreferredSize(new java.awt.Dimension(400, 100));
      P1Area.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P1Hand.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
      P1Hand.setName("P1Hand"); // NOI18N
      P1Hand.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P1HandText.setText(resourceMap.getString("P1HandText.text")); // NOI18N
      P1HandText.setName("P1HandText"); // NOI18N
      P1Hand.add(P1HandText, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, -1, -1));

      P1Area.add(P1Hand, new org.netbeans.lib.awtextra.AbsoluteConstraints(200, 10, 80, 80));

      P1Discard.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
      P1Discard.setName("P1Discard"); // NOI18N
      P1Discard.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P1DiscardText.setText(resourceMap.getString("P1DiscardText.text")); // NOI18N
      P1DiscardText.setName("P1DiscardText"); // NOI18N
      P1Discard.add(P1DiscardText, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 30, -1, -1));

      P1Area.add(P1Discard, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 10, 70, 70));

      P1Deck.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
      P1Deck.setName("P1Deck"); // NOI18N
      P1Deck.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P1DeckText.setText(resourceMap.getString("P1DeckText.text")); // NOI18N
      P1DeckText.setName("P1DeckText"); // NOI18N
      P1Deck.add(P1DeckText, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 30, -1, -1));

      P1Area.add(P1Deck, new org.netbeans.lib.awtextra.AbsoluteConstraints(372, 12, 70, 80));

      P1Character.setFont(resourceMap.getFont("P1Character.font")); // NOI18N
      P1Character.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
      P1Character.setText(resourceMap.getString("P1Character.text")); // NOI18N
      P1Character.setName("P1Character"); // NOI18N
      P1Area.add(P1Character, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, 100, 30));

      playArea.setBackground(resourceMap.getColor("playArea.background")); // NOI18N
      playArea.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
      playArea.setName("playArea"); // NOI18N
      playArea.setPreferredSize(new java.awt.Dimension(400, 290));

      lane0.setBackground(resourceMap.getColor("lane0.background")); // NOI18N
      lane0.setName("lane0"); // NOI18N
      lane0.setPreferredSize(new java.awt.Dimension(150, 300));

      org.jdesktop.layout.GroupLayout lane0Layout = new org.jdesktop.layout.GroupLayout(lane0);
      lane0.setLayout(lane0Layout);
      lane0Layout.setHorizontalGroup(
         lane0Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 150, Short.MAX_VALUE)
      );
      lane0Layout.setVerticalGroup(
         lane0Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 469, Short.MAX_VALUE)
      );

      lane2.setBackground(resourceMap.getColor("lane2.background")); // NOI18N
      lane2.setName("lane2"); // NOI18N
      lane2.setPreferredSize(new java.awt.Dimension(150, 100));

      org.jdesktop.layout.GroupLayout lane2Layout = new org.jdesktop.layout.GroupLayout(lane2);
      lane2.setLayout(lane2Layout);
      lane2Layout.setHorizontalGroup(
         lane2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 151, Short.MAX_VALUE)
      );
      lane2Layout.setVerticalGroup(
         lane2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(0, 469, Short.MAX_VALUE)
      );

      lane1.setBackground(resourceMap.getColor("lane1.background")); // NOI18N
      lane1.setName("lane1"); // NOI18N
      lane1.setPreferredSize(new java.awt.Dimension(150, 290));
      lane1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      org.jdesktop.layout.GroupLayout playAreaLayout = new org.jdesktop.layout.GroupLayout(playArea);
      playArea.setLayout(playAreaLayout);
      playAreaLayout.setHorizontalGroup(
         playAreaLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(playAreaLayout.createSequentialGroup()
            .add(lane0, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(lane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 155, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .add(lane2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 151, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );
      playAreaLayout.setVerticalGroup(
         playAreaLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(lane0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 469, Short.MAX_VALUE)
         .add(org.jdesktop.layout.GroupLayout.TRAILING, lane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 469, Short.MAX_VALUE)
         .add(lane2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 469, Short.MAX_VALUE)
      );

      P2Area.setBackground(resourceMap.getColor("P2Area.background")); // NOI18N
      P2Area.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
      P2Area.setName("P2Area"); // NOI18N
      P2Area.setPreferredSize(new java.awt.Dimension(400, 100));
      P2Area.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P2Hand.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
      P2Hand.setName("P2Hand"); // NOI18N
      P2Hand.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P2HandText.setText(resourceMap.getString("P2HandText.text")); // NOI18N
      P2HandText.setName("P2HandText"); // NOI18N
      P2Hand.add(P2HandText, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, -1, -1));

      P2Area.add(P2Hand, new org.netbeans.lib.awtextra.AbsoluteConstraints(170, 10, 80, 80));

      P2Discard.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
      P2Discard.setName("P2Discard"); // NOI18N
      P2Discard.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P2DiscardText.setText(resourceMap.getString("P2DiscardText.text")); // NOI18N
      P2DiscardText.setName("P2DiscardText"); // NOI18N
      P2Discard.add(P2DiscardText, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 30, -1, -1));

      P2Area.add(P2Discard, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 20, 70, 70));

      P2Deck.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));
      P2Deck.setName("P2Deck"); // NOI18N
      P2Deck.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

      P2DeckText.setText(resourceMap.getString("P2DeckText.text")); // NOI18N
      P2DeckText.setName("P2DeckText"); // NOI18N
      P2Deck.add(P2DeckText, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 32, -1, -1));

      P2Area.add(P2Deck, new org.netbeans.lib.awtextra.AbsoluteConstraints(21, 10, 70, 80));

      P2Character.setFont(resourceMap.getFont("P2Character.font")); // NOI18N
      P2Character.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
      P2Character.setText(resourceMap.getString("P2Character.text")); // NOI18N
      P2Character.setName("P2Character"); // NOI18N
      P2Area.add(P2Character, new org.netbeans.lib.awtextra.AbsoluteConstraints(340, 56, 100, 30));

      org.jdesktop.layout.GroupLayout mainPanelLayout = new org.jdesktop.layout.GroupLayout(mainPanel);
      mainPanel.setLayout(mainPanelLayout);
      mainPanelLayout.setHorizontalGroup(
         mainPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(playArea, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 458, Short.MAX_VALUE)
         .add(P2Area, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 458, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
         .add(P1Area, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 458, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
      );
      mainPanelLayout.setVerticalGroup(
         mainPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(mainPanelLayout.createSequentialGroup()
            .add(P1Area, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(playArea, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 471, Short.MAX_VALUE)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
            .add(P2Area, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
      );

      menuBar.setName("menuBar"); // NOI18N

      javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(brawlcardgame.BrawlCardGameApp.class).getContext().getActionMap(BrawlCardGameView.class, this);
      fileMenu.setAction(actionMap.get("startNewGame")); // NOI18N
      fileMenu.setText(resourceMap.getString("fileMenu.text")); // NOI18N
      fileMenu.setName("fileMenu"); // NOI18N

      newGameMenuItem.setAction(actionMap.get("startNewGame")); // NOI18N
      newGameMenuItem.setText(resourceMap.getString("newGameMenuItem.text")); // NOI18N
      newGameMenuItem.setName("newGameMenuItem"); // NOI18N
      fileMenu.add(newGameMenuItem);

      exitMenuItem.setAction(actionMap.get("quit")); // NOI18N
      exitMenuItem.setName("exitMenuItem"); // NOI18N
      fileMenu.add(exitMenuItem);

      menuBar.add(fileMenu);

      helpMenu.setAction(actionMap.get("showInstructionsBox")); // NOI18N
      helpMenu.setText(resourceMap.getString("helpMenu.text")); // NOI18N
      helpMenu.setName("helpMenu"); // NOI18N

      aboutMenuItem.setAction(actionMap.get("showInstructionsBox")); // NOI18N
      aboutMenuItem.setText(resourceMap.getString("aboutMenuItem.text")); // NOI18N
      aboutMenuItem.setName("aboutMenuItem"); // NOI18N
      helpMenu.add(aboutMenuItem);

      descriptionsMenuItem.setAction(actionMap.get("showCardDescriptionsBox")); // NOI18N
      descriptionsMenuItem.setText(resourceMap.getString("descriptionsMenuItem.text")); // NOI18N
      descriptionsMenuItem.setName("descriptionsMenuItem"); // NOI18N
      helpMenu.add(descriptionsMenuItem);

      menuBar.add(helpMenu);

      setComponent(mainPanel);
      setMenuBar(menuBar);
   }// </editor-fold>//GEN-END:initComponents

    private void mainPanelKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_mainPanelKeyPressed
       this.controller.doAction(new PlayerAction(new Character(evt.getKeyChar())));
    }//GEN-LAST:event_mainPanelKeyPressed
   // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JPanel P1Area;
   private javax.swing.JLabel P1Character;
   private javax.swing.JPanel P1Deck;
   private javax.swing.JLabel P1DeckText;
   private javax.swing.JPanel P1Discard;
   private javax.swing.JLabel P1DiscardText;
   private javax.swing.JPanel P1Hand;
   private javax.swing.JLabel P1HandText;
   private javax.swing.JPanel P2Area;
   private javax.swing.JLabel P2Character;
   private javax.swing.JPanel P2Deck;
   private javax.swing.JLabel P2DeckText;
   private javax.swing.JPanel P2Discard;
   private javax.swing.JLabel P2DiscardText;
   private javax.swing.JPanel P2Hand;
   private javax.swing.JLabel P2HandText;
   private javax.swing.JMenuItem descriptionsMenuItem;
   private javax.swing.JPanel lane0;
   private javax.swing.JPanel lane1;
   private javax.swing.JPanel lane2;
   private javax.swing.JPanel mainPanel;
   private javax.swing.JMenuBar menuBar;
   private javax.swing.JMenuItem newGameMenuItem;
   private javax.swing.JPanel playArea;
   // End of variables declaration//GEN-END:variables
   private JDialog instructionsBox;
   private JDialog descriptionsBox;

   private void initViewHierarchy()
   {
      lanes = new ArrayList<JPanel>(3);

      // Add them to the list for easy lookup
      lanes.add(0, lane0);
      lanes.add(1, lane1);
      lanes.add(2, lane2);

      for (JPanel lane : this.lanes)
      {
         // Configure layout of the lane panels
         lane.setLayout(new AbsoluteLayout());
      }
   }

   public void drawView()
   {
      // Clear everything and redraw
      JPanel lane;

      for (int currentLane = 0; currentLane < lanes.size(); currentLane++)
      {
         // Clear the lane
         lane = lanes.get(currentLane);
         lane.removeAll();
         lane.repaint();

         // If there is something in that lane, draw it
         if (currentLane < state.getNumberOfLanes())
         {
            // Draw a base in the lane
            String baseText = "Base (";
            JLabel baseLabel = new JLabel();
            JPanel base = new JPanel();
            base.setBorder(new LineBorder(Color.black));
            base.setBackground(new java.awt.Color(220, 220, 220));
            base.setPreferredSize(new Dimension(70, 100));
            base.setLayout(new AbsoluteLayout());
            base.setVisible(true);

            // Construct the label for the base indicating which base modifiers
            // are affecting it
            if (state.getLane(currentLane).isFrozen())
            {
               baseText = "Frozen! (";
               baseLabel.setForeground(Color.white);
               base.setBackground(Color.black);
            }
            for (BaseModifierCard card : state.getLane(currentLane).getBaseModifiers())
            {
               if (card.getClass() != FreezeCard.class)
               {
                  baseText += card.display().charAt(0);
               }
            }
            baseText += ")";

            baseLabel.setText(baseText);
            base.add(baseLabel, new AbsoluteConstraints(5, 40));
            lane.add(base, new AbsoluteConstraints(kHorizCenter, kVertCenter));

            // For both directions of card stacks
            for (Direction dir : Direction.values())
            {
               // Get the stack in that direction
               ArrayList<BrawlCard> stack = state.getLane(currentLane).getStack(dir);

               // Go through each of its cards and draw them to the ui
               for (int curr = 0; curr < stack.size(); curr++)
               {
                  if (dir == Direction.down)
                  {
                     //  65 is the offset from the center to get it past the base
                     drawCardInLane(lane, stack.get(curr), kVertCenter + 105
                         + curr * kCardOffset);
                  }
                  else
                  {
                     // 65 is the offset from the center to get it past the base
                     drawCardInLane(lane, stack.get(curr), kVertCenter - 25
                         - curr * kCardOffset);
                  }
               }
            }
         }

         // Redraw the decks
         if ((Boolean) SettingsManager.getSettingValue(Setting.showCardsLeftInDeck))
         {
            P1DeckText.setText(String.valueOf(state.getPlayers().get(PlayerID.one).getDeckSize()));
            P2DeckText.setText(String.valueOf(state.getPlayers().get(PlayerID.two).getDeckSize()));
         }

         // Draw the player's character's name
         if ((Boolean) SettingsManager.getSettingValue(Setting.showCharacterNames))
         {
            P1Character.setText(((BrawlCharacter) SettingsManager.getSettingValue(Setting.P1Character)).
                name());
            P2Character.setText(((BrawlCharacter) SettingsManager.getSettingValue(Setting.P2Character)).
                name());
         }


         // Refresh both player's hands
         BrawlCard card = state.getPlayers().get(PlayerID.one).getHand();
         if (card != null)
         {
            P1Hand.setVisible(true);
            P1Hand.setBackground(card.getColor().getDisplayColor());
            P1HandText.setText(card.display());
         }
         else
         {
            P1Hand.setVisible(false);
         }

         card = state.getPlayers().get(PlayerID.two).getHand();
         if (card != null)
         {
            P2Hand.setVisible(true);
            P2Hand.setBackground(card.getColor().getDisplayColor());
            P2HandText.setText(card.display());
         }
         else
         {
            P2Hand.setVisible(false);
         }

         // Refresh both player's discards
         card = state.getPlayers().get(PlayerID.one).getTopOfDiscard();
         if (card != null)
         {
            P1Discard.setVisible(true);
            P1Discard.setBackground(card.getColor().getDisplayColor());
            P1DiscardText.setText(card.display());
         }
         else
         {
            P1Discard.setVisible(false);
         }

         card = state.getPlayers().get(PlayerID.two).getTopOfDiscard();
         if (card != null)
         {
            P2Discard.setVisible(true);
            P2Discard.setBackground(card.getColor().getDisplayColor());
            P2DiscardText.setText(card.display());
         }
         else
         {
            P2Discard.setVisible(false);
         }
      }
   }

   private void drawCardInLane(JPanel lane, BrawlCard card, int y)
   {
      JPanel cardPanel = new JPanel(new AbsoluteLayout());
      cardPanel.setPreferredSize(new Dimension(70, 20));
      cardPanel.setBackground(card.getColor().getDisplayColor());
      cardPanel.setBorder(new LineBorder(Color.black));
      cardPanel.add(new JLabel(card.display()), new AbsoluteConstraints(2, 0));
      lane.add(cardPanel, new AbsoluteConstraints(kHorizCenter, y));
   }

   public void update(Observable o, Object o1)
   {
      this.drawView();
   }

   public void showMessage(String messageTitle, String messageBody)
   {
      JOptionPane.showMessageDialog(this.mainPanel, messageBody, messageTitle,
          JOptionPane.INFORMATION_MESSAGE);
   }

   public void showStartupErrors(ArrayList<String> errors)
   {
      StringBuilder errorMessages = new StringBuilder();
      JTextPane messagePane = new JTextPane();
      HTMLEditorKit kit = new HTMLEditorKit();
      HTMLDocument doc = new HTMLDocument();

      messagePane.setEditable(false);
      messagePane.setEditorKit(kit);
      messagePane.setDocument(doc);

      errorMessages.append("<font size='6' align='center'>The following problems were encountered during startup:").
          append("</font><br><br>");

      for (String errorMessage : errors)
      {
         errorMessages.append(errorMessage).append("<br><br>");
      }
      
      try
      {
         kit.insertHTML(doc, doc.getLength(), errorMessages.toString(), 0, 0, null);
      }
      catch (Exception ex)
      {
         System.out.println("Strange error that should be logically impossible by static analysis");
      }

      JScrollPane messages = new JScrollPane(messagePane);
      messages.setPreferredSize(new Dimension(600, 500));

      JOptionPane.showMessageDialog(this.mainPanel, messages, "Error", JOptionPane.PLAIN_MESSAGE);
   }

   @Action
   public void startNewGame()
   {
      try
      {
         this.state.startNewGame();

      }
      catch (Exception ex)
      {
         // This should never happen since all critical exceptions are confined to initialization
         // procedures
         showMessage("Error", "Failed to start new game for unknown reason");
      }
      drawView();
   }
}
